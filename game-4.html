<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Generative Maze Game</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    background: #000;
    overflow: hidden;
    height: 100%;
    width: 100%;
    font-family: system-ui, sans-serif;
    color: #eee;
  }
  #gameCanvas {
    display: block;
    margin: 0;
    background: #000;
  }
  #ui-overlay {
    position: fixed;
    inset: 0;
    pointer-events: none;
  }
  #messageBox {
    position: absolute;
    max-width: 60%;
    left: 50%;
    top: 20%;
    transform: translateX(-50%);
    background: rgba(10, 10, 10, 0.95);
    border: 1px solid #666;
    padding: 16px 20px;
    border-radius: 8px;
    display: none;
    pointer-events: auto;
    box-shadow: 0 0 20px rgba(0,0,0,0.8);
  }
  #messageBox h2 {
    margin: 0 0 8px;
    font-size: 18px;
    color: #ffd54a;
  }
  #messageBox p {
    margin: 0 0 12px;
    font-size: 14px;
    line-height: 1.4;
  }
  #messageBox button {
    padding: 6px 14px;
    border-radius: 4px;
    border: none;
    background: #ffd54a;
    color: #000;
    font-weight: 600;
    cursor: pointer;
  }
  #messageBox button:hover {
    background: #ffeb7a;
  }
  #levelLabel {
    position: absolute;
    left: 16px;
    top: 12px;
    font-size: 14px;
    color: #aaa;
    text-shadow: 0 0 4px #000;
    pointer-events: none;
  }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="ui-overlay">
  <div id="levelLabel"></div>
  <div id="messageBox">
    <h2 id="messageTitle"></h2>
    <p id="messageText"></p>
    <button id="messageClose">Close</button>
  </div>
</div>

<script>
(() => {
/* ========== CANVAS & RESIZE ========== */
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const messageBox = document.getElementById("messageBox");
const messageTitle = document.getElementById("messageTitle");
const messageText = document.getElementById("messageText");
const messageClose = document.getElementById("messageClose");
const levelLabel = document.getElementById("levelLabel");

let width, height;
function resizeCanvas() {
  width = window.innerWidth;
  height = window.innerHeight;
  const aspect = 16 / 9;
  let w = width;
  let h = width / aspect;
  if (h > height) {
    h = height;
    w = h * aspect;
  }
  canvas.width = w;
  canvas.height = h;
  canvas.style.position = "absolute";
  canvas.style.left = ((window.innerWidth - w) / 2) + "px";
  canvas.style.top = ((window.innerHeight - h) / 2) + "px";
}
window.addEventListener("resize", resizeCanvas);
resizeCanvas();

/* ========== GAME STATE ========== */
let level = 1;
let cols, rows, cellSize;
let maze = [];
let player = { x: 0, y: 0, dirX: 1, dirY: 0 };
let playerRadius = 0.28;
let playerVisible = true;
let keys = [];
let keysCollected = 0;
let totalKeys = 3;
let exitCell = null;
let exitVisible = false;
let wallPulse = null;
let fadeAlpha = 1;
let fadingIn = true;
let fadingOut = false;
let fadeCallback = null;
let lastTimeStamp = 0;
let moveSpeed = 5;
let input = { up: false, down: false, left: false, right: false };
let messageOpen = false;
let exiting = false;

/* ========== TEXT ARRAYS ========== */
const keyMessages = [
  [
    "You found a fragment of hope.",
    "The maze whispers: keep going.",
    "A memory flickers in the dark.",
    "You are not as lost as you feel.",
    "Every step rewrites your story."
  ],
  [
    "Another key, another possibility.",
    "The walls remember where you’ve been.",
    "Courage is just fear that kept walking.",
    "You’re closer than you think.",
    "The silence here is listening."
  ],
  [
    "The last key hums with intent.",
    "Endings are just disguised beginnings.",
    "You’ve carried more weight than this.",
    "The maze bends to your persistence.",
    "You are the constant in this shifting place."
  ]
];

const wallMessages = [
  "The wall pulses like a buried heartbeat.",
  "You feel watched, but see no eyes.",
  "Something here remembers you.",
  "The stone is warm, as if alive.",
  "You hear a voice, but it’s your own.",
  "The maze shifts when you’re not looking.",
  "You almost recall a dream about this place.",
  "The air thickens with unspoken questions.",
  "You sense an exit long before you see it.",
  "Not all prisons have visible bars."
];

/* ========== MESSAGE BOX ========== */
function showMessage(title, text, onClose) {
  messageTitle.textContent = title;
  messageText.textContent = text;
  messageBox.style.display = "block";
  messageOpen = true;
  messageClose.onclick = () => {
    messageBox.style.display = "none";
    messageOpen = false;
    if (onClose) onClose();
  };
}

/* ========== MAZE GENERATION ========== */
function generateMaze() {
  const base = 12;
  cols = base + level * 2;
  rows = Math.round((cols * 9) / 16);
  if (rows < 8) rows = 8;
  cellSize = Math.min(canvas.width / cols, canvas.height / rows);

  maze = [];
  for (let y = 0; y < rows; y++) {
    const row = [];
    for (let x = 0; x < cols; x++) {
      row.push({
        x, y,
        visited: false,
        walls: { top: true, right: true, bottom: true, left: true }
      });
    }
    maze.push(row);
  }

  function neighbors(cell) {
    const list = [];
    const { x, y } = cell;
    if (y > 0) list.push(maze[y - 1][x]);
    if (x < cols - 1) list.push(maze[y][x + 1]);
    if (y < rows - 1) list.push(maze[y + 1][x]);
    if (x > 0) list.push(maze[y][x - 1]);
    return list.filter(n => !n.visited);
  }

  const stack = [];
  const start = maze[0][0];
  start.visited = true;
  stack.push(start);

  while (stack.length) {
    const current = stack[stack.length - 1];
    const nbs = neighbors(current);
    if (!nbs.length) {
      stack.pop();
    } else {
      const next = nbs[Math.floor(Math.random() * nbs.length)];
      if (next.x === current.x && next.y === current.y - 1) {
        current.walls.top = false;
        next.walls.bottom = false;
      } else if (next.x === current.x + 1 && next.y === current.y) {
        current.walls.right = false;
        next.walls.left = false;
      } else if (next.x === current.x && next.y === current.y + 1) {
        current.walls.bottom = false;
        next.walls.top = false;
      } else if (next.x === current.x - 1 && next.y === current.y) {
        current.walls.left = false;
        next.walls.right = false;
      }
      next.visited = true;
      stack.push(next);
    }
  }
}

/* ========== LEVEL SETUP ========== */
function randomFloorCell() {
  return {
    x: Math.floor(Math.random() * cols),
    y: Math.floor(Math.random() * rows)
  };
}

function setupLevel() {
  generateMaze();

  const corners = [
    { x: 0, y: 0 },
    { x: cols - 1, y: 0 },
    { x: cols - 1, y: rows - 1 },
    { x: 0, y: rows - 1 }
  ];
  const spawn = corners[Math.floor(Math.random() * corners.length)];
  player.x = spawn.x + 0.5;
  player.y = spawn.y + 0.5;
  player.dirX = 1;
  player.dirY = 0;
  playerVisible = true;
  exiting = false;

  keys = [];
  keysCollected = 0;
  const used = new Set();
  used.add(spawn.x + "," + spawn.y);

  for (let i = 0; i < totalKeys; i++) {
    let cell;
    do {
      cell = randomFloorCell();
    } while (used.has(cell.x + "," + cell.y));
    used.add(cell.x + "," + cell.y);
    keys.push({
      x: cell.x + 0.5,
      y: cell.y + 0.5,
      collected: false,
      visible: i === 0
    });
  }

  let exit;
  do {
    exit = randomFloorCell();
  } while (used.has(exit.x + "," + exit.y));
  exitCell = { x: exit.x + 0.5, y: exit.y + 0.5 };
  exitVisible = false;

  const wx = Math.floor(Math.random() * cols);
  const wy = Math.floor(Math.random() * rows);
  const sides = ["top", "right", "bottom", "left"];
  wallPulse = { x: wx, y: wy, side: sides[Math.floor(Math.random() * sides.length)] };

  levelLabel.textContent = "Level " + level;
  startFadeIn();
}

/* ========== FADE ========== */
function startFadeIn() {
  fadeAlpha = 1;
  fadingIn = true;
  fadingOut = false;
  fadeCallback = null;
}
function startFadeOut(cb) {
  fadeAlpha = 0;
  fadingOut = true;
  fadingIn = false;
  fadeCallback = cb || null;
}

/* ========== INPUT ========== */
window.addEventListener("keydown", e => {
  if (messageOpen || exiting) return;
  if (["ArrowUp","w","W"].includes(e.key)) input.up = true;
  if (["ArrowDown","s","S"].includes(e.key)) input.down = true;
  if (["ArrowLeft","a","A"].includes(e.key)) input.left = true;
  if (["ArrowRight","d","D"].includes(e.key)) input.right = true;
});
window.addEventListener("keyup", e => {
  if (["ArrowUp","w","W"].includes(e.key)) input.up = false;
  if (["ArrowDown","s","S"].includes(e.key)) input.down = false;
  if (["ArrowLeft","a","A"].includes(e.key)) input.left = false;
  if (["ArrowRight","d","D"].includes(e.key)) input.right = false;
});

/* ========== COLLISION HELPERS ========== */
function getCell(x, y) {
  const cx = Math.floor(x);
  const cy = Math.floor(y);
  if (cx < 0 || cy < 0 || cx >= cols || cy >= rows) return null;
  return maze[cy][cx];
}

function moveWithCollision(dx, dy) {
  const r = playerRadius;

  if (dx !== 0) {
    let newX = player.x + dx;
    const cy = Math.floor(player.y);
    const cx = Math.floor(player.x);

    if (dx > 0) {
      const cell = getCell(cx, cy);
      if (cell && cell.walls.right) {
        const limit = (cx + 1) - r;
        if (newX > limit) newX = limit;
      }
    } else {
      const cell = getCell(cx, cy);
      if (cell && cell.walls.left) {
        const limit = cx + r;
        if (newX < limit) newX = limit;
      }
    }

    newX = Math.max(r, Math.min(cols - r, newX));
    player.x = newX;
  }

  if (dy !== 0) {
    let newY = player.y + dy;
    const cx = Math.floor(player.x);
    const cy = Math.floor(player.y);

    if (dy > 0) {
      const cell = getCell(cx, cy);
      if (cell && cell.walls.bottom) {
        const limit = (cy + 1) - r;
        if (newY > limit) newY = limit;
      }
    } else {
      const cell = getCell(cx, cy);
      if (cell && cell.walls.top) {
        const limit = cy + r;
        if (newY < limit) newY = limit;
      }
    }

    newY = Math.max(r, Math.min(rows - r, newY));
    player.y = newY;
  }
}

/* ========== UPDATE PLAYER ========== */
function updatePlayer(dt) {
  if (messageOpen || exiting) return;

  let vx = 0, vy = 0;
  if (input.up) vy -= 1;
  if (input.down) vy += 1;
  if (input.left) vx -= 1;
  if (input.right) vx += 1;

  if (vx !== 0 || vy !== 0) {
    const len = Math.hypot(vx, vy);
    vx /= len; vy /= len;
    player.dirX = vx;
    player.dirY = vy;

    const move = (moveSpeed * dt) / (1000 / 60);
    const step = move / cellSize;

    moveWithCollision(vx * step, vy * step);
  }

  keys.forEach((k, idx) => {
    if (!k.collected && k.visible) {
      const dx = k.x - player.x;
      const dy = k.y - player.y;
      if (Math.hypot(dx, dy) < 0.3) {
        k.collected = true;
        keysCollected++;
        if (keysCollected < totalKeys) {
          const next = keys.find(kk => !kk.collected && !kk.visible);
          if (next) next.visible = true;
        } else {
          exitVisible = true;
        }
        const msgArray = keyMessages[Math.min(idx, keyMessages.length - 1)];
        const msg = msgArray[Math.floor(Math.random() * msgArray.length)];
        showMessage("Key " + (idx + 1), msg);
      }
    }
  });

  if (exitVisible && exitCell && !exiting) {
    const dx = exitCell.x - player.x;
    const dy = exitCell.y - player.y;
    if (Math.hypot(dx, dy) < 0.4) {
      exiting = true;
      playerVisible = false;
      startFadeOut(() => {
        level++;
        setupLevel();
      });
    }
  }

  if (wallPulse) {
    const dx = (wallPulse.x + 0.5) - player.x;
    const dy = (wallPulse.y + 0.5) - player.y;
    if (Math.hypot(dx, dy) < 1.2) {
      const msg = wallMessages[Math.floor(Math.random() * wallMessages.length)];
      showMessage("The Wall", msg);
      wallPulse = null; // remove purple glow permanently after interaction
    }
  }
}

/* ========== DRAW HELPERS ========== */
function drawKeyShape(px, py, r, t) {
  const pulse = 0.9 + 0.1 * Math.sin(t * 0.5);
  const size = r * pulse;

  ctx.save();
  ctx.translate(px, py);
  ctx.lineWidth = 3;
  ctx.strokeStyle = "#4af";
  ctx.fillStyle = "#4af";
  ctx.shadowColor = "#4af";
  ctx.shadowBlur = 10;

  ctx.beginPath();
  ctx.arc(0, 0, size * 0.5, 0, Math.PI * 2);
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(size * 0.5, 0);
  ctx.lineTo(size * 1.4, 0);
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(size * 1.4, 0);
  ctx.lineTo(size * 1.4, size * 0.3);
  ctx.moveTo(size * 1.2, 0);
  ctx.lineTo(size * 1.2, -size * 0.3);
  ctx.stroke();

  ctx.restore();
}

/* ========== DRAW MAZE ========== */
function drawMaze() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.save();
  ctx.translate(
    (canvas.width - cols * cellSize) / 2,
    (canvas.height - rows * cellSize) / 2
  );

  const t = performance.now() / 1000;

  ctx.lineWidth = 2;
  ctx.strokeStyle = "#aaa";
  ctx.shadowColor = "rgba(255,255,255,0.25)";
  ctx.shadowBlur = 4;

  for (let y = 0; y < rows; y++) {
    for (let x = 0; x < cols; x++) {
      const cell = maze[y][x];
      const px = x * cellSize;
      const py = y * cellSize;

      ctx.beginPath();
      if (cell.walls.top) {
        ctx.moveTo(px, py);
        ctx.lineTo(px + cellSize, py);
      }
      if (cell.walls.right) {
        ctx.moveTo(px + cellSize, py);
        ctx.lineTo(px + cellSize, py + cellSize);
      }
      if (cell.walls.bottom) {
        ctx.moveTo(px + cellSize, py + cellSize);
        ctx.lineTo(px, py + cellSize);
      }
      if (cell.walls.left) {
        ctx.moveTo(px, py + cellSize);
        ctx.lineTo(px, py);
      }
      ctx.stroke();
    }
  }

  const pcx = Math.floor(player.x);
  const pcy = Math.floor(player.y);
  const radius = 1;
  ctx.lineWidth = 3;
  ctx.strokeStyle = "#fff";
  ctx.shadowColor = "rgba(255,255,200,0.7)";
  ctx.shadowBlur = 10;

  for (let y = pcy - radius; y <= pcy + radius; y++) {
    for (let x = pcx - radius; x <= pcx + radius; x++) {
      if (x < 0 || y < 0 || x >= cols || y >= rows) continue;
      const cell = maze[y][x];
      const px = x * cellSize;
      const py = y * cellSize;
      ctx.beginPath();
      if (cell.walls.top) {
        ctx.moveTo(px, py);
        ctx.lineTo(px + cellSize, py);
      }
      if (cell.walls.right) {
        ctx.moveTo(px + cellSize, py);
        ctx.lineTo(px + cellSize, py + cellSize);
      }
      if (cell.walls.bottom) {
        ctx.moveTo(px + cellSize, py + cellSize);
        ctx.lineTo(px, py + cellSize);
      }
      if (cell.walls.left) {
        ctx.moveTo(px, py + cellSize);
        ctx.lineTo(px, py);
      }
      ctx.stroke();
    }
  }

  if (wallPulse) {
    const pulse = 0.5 + 0.5 * Math.sin(t * 4);
    const px = wallPulse.x * cellSize;
    const py = wallPulse.y * cellSize;
    ctx.save();
    ctx.shadowColor = "rgba(180, 80, 255," + (0.7 * pulse) + ")";
    ctx.shadowBlur = 20;
    ctx.strokeStyle = "rgba(200, 120, 255,0.9)";
    ctx.lineWidth = 3;
    ctx.beginPath();
    if (wallPulse.side === "top") {
      ctx.moveTo(px, py);
      ctx.lineTo(px + cellSize, py);
    } else if (wallPulse.side === "right") {
      ctx.moveTo(px + cellSize, py);
      ctx.lineTo(px + cellSize, py + cellSize);
    } else if (wallPulse.side === "bottom") {
      ctx.moveTo(px + cellSize, py + cellSize);
      ctx.lineTo(px, py + cellSize);
    } else if (wallPulse.side === "left") {
      ctx.moveTo(px, py + cellSize);
      ctx.lineTo(px, py);
    }
    ctx.stroke();
    ctx.restore();
  }

  keys.forEach(k => {
    if (!k.collected && k.visible) {
      const kx = k.x * cellSize;
      const ky = k.y * cellSize;
      drawKeyShape(kx, ky, cellSize * 0.35, t);
    }
  });

  if (exitVisible && exitCell) {
    const ex = exitCell.x * cellSize;
    const ey = exitCell.y * cellSize;
    const r = cellSize * 0.35;
    const pulse = 0.5 + 0.5 * Math.sin(t * 3);
    ctx.save();
    const grad = ctx.createRadialGradient(ex, ey, r * 0.2, ex, ey, r);
    grad.addColorStop(0, "rgba(255,80,80,1)");
    grad.addColorStop(1, "rgba(120,0,0,0)");
    ctx.fillStyle = grad;
    ctx.globalAlpha = 0.7 + 0.3 * pulse;
    ctx.beginPath();
    ctx.arc(ex, ey, r, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
    ctx.restore();
  }

  if (playerVisible) {
    const pxPlayer = player.x * cellSize;
    const pyPlayer = player.y * cellSize;
    const orbPulse = 0.9 + 0.1 * Math.sin(t * 2);
    const orbR = playerRadius * cellSize * orbPulse;

    ctx.save();
    ctx.translate(pxPlayer, pyPlayer);
    ctx.shadowColor = "rgba(255, 230, 120, 0.4)";
    ctx.shadowBlur = 10;
    const orbGrad = ctx.createRadialGradient(0, 0, orbR * 0.2, 0, 0, orbR);
    orbGrad.addColorStop(0, "rgba(255,255,180,1)");
    orbGrad.addColorStop(1, "rgba(255,210,80,0.05)");
    ctx.fillStyle = orbGrad;
    ctx.beginPath();
    ctx.arc(0, 0, orbR, 0, Math.PI * 2);
    ctx.fill();

    const angle = Math.atan2(player.dirY, player.dirX);
    const dirLen = orbR * 1.4;
    ctx.fillStyle = "rgba(255,255,200,0.9)";
    ctx.beginPath();
    const a1 = angle;
    const a2 = angle + 0.4;
    const a3 = angle - 0.4;
    ctx.moveTo(Math.cos(a1) * dirLen, Math.sin(a1) * dirLen);
    ctx.lineTo(Math.cos(a2) * orbR * 0.4, Math.sin(a2) * orbR * 0.4);
    ctx.lineTo(Math.cos(a3) * orbR * 0.4, Math.sin(a3) * orbR * 0.4);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }

  ctx.restore();
}

/* ========== FADE DRAW/UPDATE ========== */
function drawFadeOverlay() {
  if (!fadingIn && !fadingOut) return;
  ctx.save();
  ctx.fillStyle = "rgba(0,0,0," + fadeAlpha.toFixed(3) + ")";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.restore();
}
function updateFade(dt) {
  const speed = 1.5;
  if (fadingIn) {
    fadeAlpha -= dt / 1000 / speed;
    if (fadeAlpha <= 0) {
      fadeAlpha = 0;
      fadingIn = false;
    }
  } else if (fadingOut) {
    fadeAlpha += dt / 1000 / speed;
    if (fadeAlpha >= 1) {
      fadeAlpha = 1;
      fadingOut = false;
      if (fadeCallback) {
        const cb = fadeCallback;
        fadeCallback = null;
        cb();
      }
    }
  }
}

/* ========== MAIN LOOP ========== */
function loop(timestamp) {
  if (!lastTimeStamp) lastTimeStamp = timestamp;
  const dt = timestamp - lastTimeStamp;
  lastTimeStamp = timestamp;

  updatePlayer(dt);
  updateFade(dt);
  drawMaze();
  drawFadeOverlay();

  requestAnimationFrame(loop);
}

setupLevel();
requestAnimationFrame(loop);
})();
</script>
</body>
</html>
